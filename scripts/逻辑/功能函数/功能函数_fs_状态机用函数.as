
_root.检查并执行时间间隔动作 = function(对象, 时间间隔, 动作函数名, 间隔名, 是否允许多次执行)
{
	if(isNaN(对象.上次动作时间[间隔名]))
	{
		if (对象.上次动作时间 === undefined)
		{
			对象.上次动作时间 = {};
		}

		对象.上次动作时间[间隔名] = _root.帧计时器.当前帧数;//默认第一次调用必执行动作，因此直接记录帧数戳
		this[动作函数名]();
	}
	else
	{
		var 帧计时器 = _root.帧计时器;
		var 当前帧数 = 帧计时器.当前帧数;
		var 需要的帧数 = 时间间隔 * 帧计时器.毫秒每帧;//乘法优化性能
		var 已过帧数 = 当前帧数 - 对象.上次动作时间[间隔名];

		if(是否允许多次执行)
		{
			var 需要执行的次数 =  Math.floor(已过帧数 / 需要的帧数);
			对象.上次动作时间[间隔名] += 需要的帧数 * 需要执行的次数;

			for (var i = 0; i < 需要执行的次数; i++)
			{
				this[动作函数名]();//多次执行情况会避免取整干扰粒度，增加帧数而不是记录帧数戳
			}
		}
		else if(已过帧数 >= 需要的帧数)
		{
			this[动作函数名]();
			对象.上次动作时间[间隔名] = 当前帧数;
		}
	}
};


_root.更新并执行时间间隔动作 = function(对象, 标签名, 动作, 间隔时间, 是否允许多次执行) 
{
    var 参数数组 = Array.prototype.slice.call(arguments, 5); // 捕获额外的参数
	if (isNaN(对象.上次动作时间[标签名])) 
	{
        if (对象.上次动作时间 === undefined) 对象.上次动作时间 = {};
        对象.上次动作时间[标签名] = _root.帧计时器.当前帧数; // 默认第一次调用必执行动作，因此直接记录帧数戳

        动作.apply(对象, 参数数组);//保证函数中的this指向自己
    } 
	else 
	{
        var 帧计时器 = _root.帧计时器;
        var 当前帧数 = 帧计时器.当前帧数;
        var 需要的帧数 = 间隔时间 * 帧计时器.毫秒每帧; // 乘法优化性能
        var 已过帧数 = 当前帧数 - 对象.上次动作时间[标签名];

        if (是否允许多次执行) 
		{
            var 需要执行的次数 = Math.floor(已过帧数 / 需要的帧数);
            对象.上次动作时间[标签名] += 需要的帧数 * 需要执行的次数;

            for (var i = 0; i < 需要执行的次数; i++) 动作.apply(对象, 参数数组);
        } 
		else if (已过帧数 >= 需要的帧数) 
		{
            动作.apply(对象, 参数数组);
            对象.上次动作时间[标签名] = 当前帧数;
        }
    }
};//更推荐的写法

_root.更新时间间隔 = function(对象, 标签名, 间隔时间) 
{
	if (isNaN(对象.上次动作时间[标签名])) 
	{
        if (对象.上次动作时间 === undefined) 对象.上次动作时间 = {};
        对象.上次动作时间[标签名] = _root.帧计时器.当前帧数; // 默认第一次调用必执行动作，因此直接记录帧数戳

        return true; // 第一次访问总是返回 true
    } 
    else 
	{
        var 当前帧数 = _root.帧计时器.当前帧数;
        var 需要的帧数 = 间隔时间 * _root.帧计时器.毫秒每帧; // 计算所需帧数
        var 已过帧数 = 当前帧数 - 对象.上次动作时间[标签名];

        if (已过帧数 >= 需要的帧数) {
            对象.上次动作时间[标签名] = 当前帧数; // 更新时间戳
            return true; // 时间间隔已经足够，返回 true
        }
    }
    return false; // 时间间隔不足，返回 false
};//裁剪移除了动作执行部分，只保留时间间隔更新


_root.按键输入检测 = function(自机,键名)
{
	if(自机._name === _root.控制目标)
	{
		return Key.isDown(键名);
	}
	
	return false;
};