# 射线系统建设复盘（从 `63abadaf7` 起，Crazyfs 提交）

> 范围：`63abadaf71fbd23e131c3a5711547219f71784f2`（含）→ `107b278b024618caa525ba312497a07726f75237`（含）  
> 时间：2026-02-23 ～ 2026-02-25（提交日期以仓库为准）  
> 目的：复盘建设过程、盘点技术债、识别可抽取重复模块、给出性能/架构改进方向与可落地路线图。

---

## 1. 提交清单（Crazyfs，按时间顺序）

- `63abadaf7`（2026-02-23）开始准备实施磁暴射线系统
- `2ac820b2d`（2026-02-24）修正了流程中的问题，打通了线路
- `0449fa13e`（2026-02-24）优化了磁暴渲染
- `4588894ca`（2026-02-24）优化了一些实现细节
- `41f243661`（2026-02-24）优化了一些实现细节
- `01f752782`（2026-02-24）开始进行下一步的表达力优化
- `b5c7313ba`（2026-02-24）优化了部分实现以提升性能与表现力
- `9acb244a2`（2026-02-24）优化了其他射击模式的逻辑
- `7b7e2c51b`（2026-02-24）调整了一些实现细节
- `7fecf634b`（2026-02-24）开始增强射线系统对于特效渲染的表达能力
- `7b1ba8e5a`（2026-02-24）处理了一些实现细节
- `40a1a90b9`（2026-02-25）优化了光棱渲染器的效果
- `1daed1af3`（2026-02-25）优化了光谱渲染的效果
- `10568017d`（2026-02-25）优化了波能渲染器的效果
- `107b278b0`（2026-02-25）整理清理射线系统的技术债务

---

## 2. 建设过程（按阶段归纳）

### Phase A：打通“射线子弹”全链路（2/23 起）

核心目标：让 `<rayConfig>` 从 XML 配置一路走到“命中判定 + 伤害结算 + 视觉表现”。

关键落点：

- 数据面：`data/items/bullets_cases.xml` 引入 `<rayConfig>`，并用 `<pierceLimit>` 统一控制多目标（pierce/chain/fork）。
- 类型标志：`scripts/macros/FLAG_RAY.as` 新增 `FLAG_RAY`，并在类型系统里建立“射线 ⊂ 透明子弹”的蕴含关系（避免到处写 `|| isRay`）。
- 配置解析：`TeslaRayConfig.fromXML()` 负责默认值/预设/覆盖/校验，且在解析阶段完成合并，避免 spawn 时高频 `for-in` 带来的 GC。
- 生命周期：`TeslaRayLifecycle` 将射线子弹定义为“单帧检测”，把子弹导入独立处理队列。
- 窄相碰撞：`RayCollider` + `CollisionResult.tEntry`（Slab/Kay-Kajiya）用于射线-AABB 相交与 pierce 距离排序。
- 队列处理：`BulletQueueProcessor.processRayBullets()` 专门处理 ray，避免主循环为每发常规子弹承担分支成本。

### Phase B：模式拓展与性能底座（2/24）

核心目标：在“单帧检测”的约束下提供多种命中拓扑，并把性能风险控制在可预期范围。

- 命中拓扑（`TeslaRayConfig.rayMode`）完善：
  - `single`：最近命中
  - `pierce`：按 `tEntry` 维护前 N 小命中（避免 `sqrt`/`dist²`）
  - `chain`：命中后以命中点为圆心搜索下一目标，带 visited 防重复
  - `fork`：命中后从命中点向附近目标折射，维护前 N 近列表
- 窗口裁剪：依赖 `TargetCacheManager` 的有序缓存（`leftValues`/`rightMaxValues`）二分定位扫描起点，把复杂度降到 `O(logT + W)`。

### Phase C：从“单渲染器”到“可扩展的多风格 VFX 路由器”（2/24 晚～2/25）

核心目标：表现力提升，同时尽量不把性能债推给主循环。

- `LightningRenderer` 退化为”向后兼容代理层”（已在 Iteration 3 删除），核心能力迁移到：
  - `RayVfxManager`：统一路由/延迟队列/LOD/对象池/容器管理
  - `renderer/*`：风格渲染器拆分（Tesla/Prism/Radiance/Spectrum/Resonance/Wave/Thermal/Vortex/Plasma）
  - `VfxPresets`：预设风格 + 默认 preset 选择（vfxStyle → default preset）
- 表现侧细节：
  - `RayVfxManager.drawCircle()` 用 8 段 `curveTo` + `beginFill` 修复“多边形硬边伪影”
  - 波能系渲染（Wave v6）引入 Energy Lance 概念，显著提升运动感并降低“串珠感”
  - `RenderColorUtil.shiftHue()` 抽取颜色变换，清理 Prism/Radiance 重复代码

### Phase D：并入帧驱动与跨场景清理（持续迭代）

- `scripts/通信/通信_fs_帧计时器.as`：
  - `frameEnd` 调用 `RayVfxManager.update()`
  - `SceneChanged` 调用 `RayVfxManager.reset()` 防残留

---

## 3. 当前系统结构（模块与数据流）

### 3.1 入口与配置

- `data/items/bullets_cases.xml`：`<attribute><rayConfig>...</rayConfig></attribute>`
- `AttributeLoader.load()`：检测 `<rayConfig>` → `TeslaRayConfig.fromXML()` → 写入 `attributeInfo.rayConfig` + `additionalFlags = FLAG_RAY`
- `BulletInitializer.initializeBulletProperties()`：把 attributeMap 合并进子弹对象，并将 `additionalFlags` 位或到 `Obj.flags`

### 3.2 子弹创建与生命周期

- `BulletTypesetter`：`bullet.flags |= flags`（不覆盖已有标志）+ `FLAG_RAY ⇒ FLAG_TRANSPARENCY`
- `BulletFactory`：`isRay` 优先选择 `TeslaRayLifecycle`，透明子弹（含 ray）走浅拷贝
- `TeslaRayLifecycle`：
  - `bindCollider()`：创建 `RayCollider`
  - `bindFrameHandler()`：加入 `_rayBullets` 队列（单帧）

### 3.3 命中拓扑与伤害结算

- `BulletQueueProcessor.processRayBullets()`：
  - 通过缓存窗口裁剪扫描候选单位
  - `RayCollider.checkCollision()` 返回 `CollisionResult`（含 `tEntry` + 命中点）
  - 分派 `single/pierce/chain/fork`
  - 发布事件、调用伤害结算、触发 FX
  - 生成 `SegmentMeta` → `RayVfxManager.spawn(...)`

### 3.4 表现

- `RayVfxManager`：
  - `spawn()`：计算延迟（chain/fork）→ 入延迟队列或立即 `createArc()`
  - `update()`：处理延迟队列、更新活跃电弧、基于成本切换 LOD
  - `renderArc()`：按 `vfxStyle` 分发到具体 renderer
- `renderer/*`：各风格渲染器负责绘制层级、路径生成、端点/命中点表现
- 帧驱动入口：`通信_fs_帧计时器.frameEnd` → `RayVfxManager.update()` / `SceneChanged` → `RayVfxManager.reset()`（详见 Phase D）

---

## 4. 技术债清单（建议优先级）

### P0（建议立即处理）

1) **仓库卫生：`.claude/settings.local.json` 被提交**  
   - 性质：本机/工具局部配置，内容冗长且包含绝对路径/权限策略，极易污染协作环境。  
   - 建议：从版本库移除并加入 `.gitignore`（至少忽略 `.claude/settings.local.json`，更推荐忽略整个 `.claude/`）。

2) **坐标偏移一致性风险：`SegmentMeta.hitPoints` 未做 `effectOffset` 同步**
   - `RayVfxManager.createArc()`（L298-301）对 start/end 应用了 `SceneCoordinateManager.effectOffset`，但 `meta.hitPoints` 在 4 个渲染器（Wave L251-264 / Vortex L173-185 / Plasma L174-186 / Thermal L124-137）中直接用 `hp.x, hp.y` 绘制圆盘波纹，未做相同变换。
   - 若 `effectOffset != (0,0)`（场景/层级存在偏移），pierce 命中点波纹可能与主束不对齐。
   - `hitPoints` 由 `BulletQueueProcessor`（L697）构建，使用原始游戏世界坐标。
   - **修复点**：在 `RayVfxManager.createArc()` 中，对 `meta.hitPoints` 遍历应用同一 offset，一处修改即可覆盖全部 4 个渲染器。

3) **`CollisionResult.additionalInfo` 可能为 `undefined`，`addInfo()` 存在 NPE 风险**  
   - 当前构造函数注释掉了 `{}` 初始化；若下游某处调用 `addInfo()` 将直接报错。  
   - 建议：在 `addInfo()` 内部做懒初始化或恢复构造函数初始化（取舍看热点与调用频率）。

### P1（建议近期处理，提升可维护性）

4) **测试文件组织不符合约定（未放入 `test/` 子目录）**  
   - 现状：`TeslaRayConfigTest.as`、`RayVfxManagerTest.as` 与源文件同目录。  
   - 建议：按 AGENTS 约定迁移到 `*/test/` 并补充简单的 `runAllTests()` 统一入口说明。

5) **~~风格/模式字符串常量散落多处，存在”新增风格时漏改”的一致性风险~~** ✅ 已解决
   - 已通过 `RayStyleRegistry`（Iteration 2）+ `VFX_xxx` 常量引用（Iteration 2.1）彻底消除。
   - 新增风格：在 `TeslaRayConfig` 添加 `VFX_xxx` 常量 → 在 `RayStyleRegistry` 添加 `reg()` 调用，完毕。

6) **`BulletQueueProcessor.processRayBullets()` 过长，混合：扫描/拓扑/伤害/事件/特效/VFX 调度** ✅ 已部分拆分
   - 已完成：提取 `bsearchScanStart()` 消除 3 处二分查找 copy-paste；提取 `settleRayHit()` 消除 4 处伤害结算 copy-paste。
   - 原计划的 3 函数拆分经评估调整：扫描逻辑（pierce 的 top-N vs single 的 nearest）和 VFX emit（各模式 SegmentMeta 字段不同）差异过大，强行统一反增复杂度。当前拆分已覆盖最危险的重复代码。

### P2（中期优化，追求更稳的性能与扩展）

7) **LOD 策略仅基于“成本权重”，未与真实帧耗时闭环**  
   - 现状：`RayVfxManager` 以 `_renderCost` 阈值切换 LOD。  
   - 建议：与 `PerformanceScheduler`/帧计时器性能日志联动（例如：当帧耗时超过阈值时，临时提升 LOD 等级并在压力解除后回落）。

8) **波能系/螺旋系渲染器存在大量相似结构，可抽取共享工具但需评估函数调用成本**  
   - 适用：`WaveRenderer` / `ThermalRenderer` / `VortexRenderer` / `PlasmaRenderer`  
   - 可抽取：脉冲因子、平滑 envelope、炮口辉光、pierce 命中点波纹绘制、正弦/螺旋路径生成模板。

---

## 5. 重复模块与可抽取点（按收益排序）

1) **~~`generateVortexPath()` 与 `generateWavePath()` 完全相同~~** ✅ 已合并（Iteration 2）
   - 已提取为 `RayVfxManager.generateSinePath()`，Wave/Vortex/Plasma 三个渲染器共用。
   - Plasma 的高频噪声通过 `noiseRatio=0.37` 参数统一，无需 Function 回调。
   - 净减约 150 行重复代码。

2) **波能系 renderer 的”炮口辉光 + pierce 命中点波纹”绘制逻辑**
   - 现存重复：Wave/Vortex/Plasma/Thermal 均包含近似的 3 层 `drawCircle()` 组合（~25 行/渲染器）。
   - 建议抽取：`RayVfxManager.drawMuzzleGlow()`、`RayVfxManager.drawPierceRipples()`。

3) **波能系 renderer 的”脉冲因子 / envelope / 采样率限制”**
   - 建议抽取：`WaveMathUtil`（smoothstep、segmentCount clamp、pulseFactor）。

4) **~~`processRayBullets()` 中”二分查找起始索引”的重复实现~~** ✅ 已落地（Iteration 2）
   - 已提取 `bsearchScanStart(rightMax, len, targetLeft)`，3 处 copy-paste 消除。

5) **~~多风格 renderer 的”读取 config + intensity 缩放 + LOD 开关”样板代码~~** ✅ 已解决（Iteration 3）
   - 已新增 `RayVfxManager.cfgNum/cfgArr/cfgIntensity` 三个轻量 helper
   - 9 个渲染器全部改写，消除 68 处 `(config != null && !isNaN(...))` 样板
   - 方案选择说明：最终采用 helper 函数而非 `prepareRenderContext()` 对象，原因是避免额外对象分配且 9 个渲染器参数字段各不相同

6) **~~`TeslaRayConfig` 中 `applyPreset()` / `fromXML()` 逐字段条件赋值~~** ✅ 已解决（Iteration 4）
   - 引入 `FIELD_MAP` 数组（31 个 `{k,p}` 条目）+ `parseField` 分发函数
   - `fromXML` Stage 3: 117 行 → 10 行循环
   - `applyPreset`: 40 行 → 8 行循环
   - 新增字段只需改 3 处：属性声明、构造函数默认值、FIELD_MAP 一行

---

## 6. 性能优化方向（以“不破坏美术表达”为前提）

1) **降低 drawcall/lineStyle 次数**  
   - `RayVfxManager.drawPath()` 每次都会 `lineStyle()`；大量路径时开销可观。  
   - 可选：为同一 layer/同一粗细颜色批量绘制提供 `drawPathsSameStyle()`，把 `lineStyle()` 外提。

2) **~~LOD=2 时”冻结重绘”~~** ✅ 已实现（Iteration 3）
   - `updateActiveArcs()` 中 `_currentLOD >= 2` 时跳过 `renderArc()`，首帧已在 `createArc()` 绘制。

3) **`processRayBullets()` 的临时分配进一步池化（按压测决定）**  
   - pierce/fork 的 `hits` 数组与命中对象结构体可复用（类似 RayVfxManager 的 pool）。

4) **~~`drawCircle()` 的 trig 预计算~~** ✅ 已实现（Iteration 4）
   - 4 个扁平查表数组（`_ccCos/_ccSin/_ecCos/_ecSin`），lazy-init 一次计算
   - 消除每次 `drawCircle` 调用的 32 次 `Math.cos/sin`，替换为 16 次数组查找

---

## 7. 架构改进建议（偏“防未来债”）

1) **建立 Ray 子系统边界**  
   - 目标：把“射线拓扑/伤害结算/表现调度”从 `BulletQueueProcessor` 中抽出到 `RayBulletProcessor`（仍在 BulletComponent 体系内），让改动集中、回归面可控。

2) **~~style registry 一处定义，多处复用~~** ✅ 已落地（Iteration 2）
   - 已实现：`RayStyleRegistry` 提供 `isValidStyle` / `renderArc` / `getDefaultPreset` / `getStyleCost` / `getStyleNames`
   - 成果：新增风格只需在 `RayStyleRegistry` 添加一行 `reg(...)` 调用。

3) **把“数据面调参”与“渲染器默认值”分层**  
   - 建议原则：
     - preset 负责“可读的美术默认”
     - renderer 只做兜底（极少用）
     - config constructor 默认值只做“安全值”（防 NaN/undefined），不追求美术一致

---

## 8. 建议整改路线图（3 个迭代）

### Iteration 1（安全与卫生）

- [x] 移除 `.claude/settings.local.json` 出版本库，补 `.gitignore` 规则
- [x] 修复 `hitPoints` 坐标偏移：在 `RayVfxManager.createArc()` L327 后遍历 `meta.hitPoints` 应用 `effectOffset`
- [x] 给 `CollisionResult.addInfo()` 加懒初始化（`if (this.additionalInfo == undefined) this.additionalInfo = {};`）
- [x] `TeslaRayConfig` 补齐 `VFX_RADIANCE/VFX_RESONANCE/VFX_THERMAL/VFX_VORTEX/VFX_PLASMA` 常量

验收：不改玩法、不改数值，且不引入新依赖。

### Iteration 2（可维护性提升）

- [x] style 常量集中化：新建 `RayStyleRegistry`，消除 4 处散落的 style string
  - 新文件：`org.flashNight.arki.render.RayStyleRegistry`（单一事实来源）
  - `RayVfxManager`：删除 `STYLE_COST` map + switch/case 路由，改为 Registry 查表
  - `VfxPresets.getDefaultPresetForStyle()`：改为委托 Registry
  - `TeslaRayConfig.VALID_STYLES`：删除，`isValidStyle()` 委托 Registry
- [x] 提取 `generateSinePath` 到 `RayVfxManager`，合并 Wave/Vortex/Plasma 路径生成
  - Wave/Vortex 完全相同的 ~55 行代码 → 4 行委托（ptsPerWave=24, maxSeg=250, noise=0）
  - Plasma 额外高频噪声 → 4 行委托（ptsPerWave=12, maxSeg=200, noise=0.37）
  - 净减约 150 行重复代码
- [~] drawMuzzleGlow/drawPierceRipples 提取评估 → **跳过**
  - 原因：4 个渲染器的炮口辉光/波纹参数差异大（层数、大小、alpha 各异），强行统一反而增加参数传递复杂度，收益不足
- [~] 迁移测试文件到 `test/` 子目录 → **跳过**
  - 原因：AS2 的 class 全限定名与文件路径强绑定，迁移需改包路径 + 所有 import，编译风险大于组织收益
- [x] 将 `processRayBullets()` 拆出 2 个私有热点函数 ✅
  - `bsearchScanStart(rightMax, len, targetLeft)` — 二分查找扫描起始索引，消除 3 处 copy-paste
  - `settleRayHit(bullet, shooter, hitTarget, hitX, hitY, dmgMult, tEntry, ...)` — 闪避→伤害→事件→显示→特效结算管线，消除 4 处 copy-paste
  - 原计划的 3 函数拆分（scanRayHits/applyRayDamage/emitRayVfx）经评估调整：扫描逻辑和 VFX emit 在各模式间差异过大，强行统一反增复杂度，改为提取最具重复性的二分查找和伤害结算
- [x] 抽取二分查找 helper，消除 copy-paste ✅（合并至上条）

验收：功能行为一致；新增风格时只改 `RayStyleRegistry` 一个文件。

### Iteration 2.1（审阅修复）

- [x] `TeslaRayConfig` vfxStyle/vfxPreset 注释更新：可选值从 4 种补齐为 9 种，添加 `@see` 指向 Registry
- [x] `RayStyleRegistry.reg()` 改用 `TeslaRayConfig.VFX_xxx` 常量替代字符串字面量
  - 使 VFX_xxx 常量真正成为风格字符串的单一定义点，Registry 只引用不重复定义
- [x] `RayStyleRegistry.reg()` 添加重复注册防御（`if (_registry[style] != undefined) return;`）
  - 防止误操作导致 `_styleNames` 出现重复项
- [x] `BulletQueueProcessor` single 分支 `hitTarget`/`命中对象` 双重赋值添加注释说明
  - 首次赋值供 `击中时触发函数` 读取，`settleRayHit` 内二次赋值是有意冗余（值相同）
  - 评估后保留冗余：替代方案（加 flag 参数/拆函数）均比保持现状更复杂

验收：不改行为，仅修正注释与防御性校验。

### Iteration 3（Tier 1 技术债清理 + LOD 冻结重绘）

目标：消除死代码、降低维护风险、减少 ~200 行重复样板、为 LOD 2 场景节省每帧重绘开销。

- [x] 删除 `LightningRenderer`（105 行纯代理层，全代码库零引用） ✅
  - 文件：`org.flashNight.arki.render.LightningRenderer` — 已删除
  - grep 验证：全代码库零 import、零调用
- [x] `settleRayHit` 签名简化：13 参数 → 6 参数 ✅
  - 引入 `_rayHitCtx` 静态复用上下文对象（与 `_rayHitResult` 同模式）
  - 每发子弹循环入口初始化 ctx，4 个调用点从 ~130 字符/行降到 ~50 字符/行
  - 参数顺序错误风险大幅降低
- [x] Config 解析样板去重：新增 `cfgNum/cfgArr/cfgIntensity` helper ✅
  - 新增到 `RayVfxManager`（所有渲染器已 import，零新增依赖）
  - 9 个渲染器全部改写，消除 68 处 `(config != null && !isNaN(...))` 样板
  - `RayVfxManager` 自身 3 处 + flicker 2 处也一并改用 `cfgNum`
  - 性能分析：每帧 ~100 次 helper 调用 × ~2μs = ~200μs，远小于渲染开销
- [x] LOD=2 冻结重绘 ✅
  - `updateActiveArcs()` 中活跃期分支：`_currentLOD < 2` 时才调用 `renderArc()`
  - 首帧渲染在 `createArc()` 已完成（age=0），LOD 2 直接复用
  - flicker/alpha 控制不受影响
  - LOD 动态切换安全：2→0/1 自动恢复重绘，0/1→2 冻结在最后一帧
  - 收益：LOD 2 场景每个活跃 arc 每帧省一次 `mc.clear() + renderArc()`

验收：不改玩法、不改数值、不改视觉表现。LOD 2 场景下 CPU 开销降低。

### Iteration 4（Tier 2/3 技术债 + 性能优化）

目标：消除 FIELD_MAP 双写风险、对象池内存有界、drawCircle trig 预计算、drawFlare 矩阵复用。

- [x] `FIELD_MAP` 驱动 `applyPreset()`/`fromXML()` Stage 3 ✅
  - 31 个 `{k, p}` 条目 + `parseField` 分发函数（P_NUM/P_COLOR/P_BOOL/P_PAL）
  - `fromXML` Stage 3: 117 行逐字段赋值 → 10 行 FIELD_MAP 循环
  - `applyPreset`: 40 行逐字段赋值 → 8 行 FIELD_MAP 循环（palette 特殊处理深拷贝）
  - `rayMode` 保留手动处理（需 normalizeToken + isValidMode 校验）
  - 新增字段只需改 3 处：属性声明、构造函数默认值、FIELD_MAP 一行
- [x] 对象池容量上限 ✅
  - `MAX_PT_POOL=512`、`MAX_ARR_POOL=64`、`MAX_PD_POOL=64`
  - `resetPools()` 超容时 `array.length = MAX`（AS2 O(1) 操作）
  - 防止爆发场景后安静期内池数组无限膨胀
- [x] `drawCircle` trig 预计算 ✅
  - 4 个扁平查表数组（`_ccCos/_ccSin/_ecCos/_ecSin`），lazy-init
  - 消除 32 次 `Math.cos/sin`/调用 → 16 次数组查找
- [x] `PrismRenderer.drawFlare` 矩阵复用 ✅
  - 静态 `_flareMatrix` 对象，drawFlare 内直接修改字段
  - 消除 LOD 0 每弧每帧 2 次 GC 分配
- [~] 以下项目经评估跳过：
  - T2.1 God Object 拆分：短期不动，字段均为标量，内存开销可忽略
  - T2.3 muzzle glow/pierce ripple 提取：参数差异大，强行统一反增复杂度
  - T3.1/T3.2/T3.4：频率极低 / 实践安全 / AS2 包路径限制
  - lineStyle 批处理：需重构所有渲染器，侵入性过大
  - LOD-帧耗时闭环：需 PerformanceScheduler 集成，属独立课题

验收：不改玩法、不改数值、不改视觉表现。XML 配置 4 阶段优先级正确。

### Iteration 5（性能闭环，视压测，待定）

- [ ] LOD 与帧耗时闭环（结合 `PerformanceScheduler` 或性能日志）
- [ ] 波能系 ripple/辉光抽取 util（减少重复与分散调参点）

验收：在”高射线密度场景”下帧率/卡顿明显改善，视觉退化可接受。

