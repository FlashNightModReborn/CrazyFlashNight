# 双枪射击与换弹系统技术文档

## 文档信息
- **创建日期**: 2025-10-26
- **版本**: 1.0
- **维护者**: 开发团队
- **文档目的**: 为后续重构和功能调整提供完整的系统架构和流程说明

---

## 目录
1. [系统架构概述](#系统架构概述)
2. [核心类说明](#核心类说明)
3. [状态机流程](#状态机流程)
4. [射击流程详解](#射击流程详解)
5. [换弹流程详解](#换弹流程详解)
6. [动画层集成](#动画层集成)
7. [关键数据结构](#关键数据结构)
8. [配置与扩展点](#配置与扩展点)
9. [已知问题与优化建议](#已知问题与优化建议)

---

## 系统架构概述

### 三层架构设计

```
┌─────────────────────────────────────────────────────────┐
│                    表现层 (Presentation)                │
│  - 双枪攻击.xml (Flash动画素材)                          │
│  - 动画帧脚本 (内嵌ActionScript)                         │
│  - UI更新 (玩家信息界面)                                 │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                    业务逻辑层 (Business Logic)           │
│  - ShootCore.as (射击核心逻辑)                           │
│  - ReloadManager.as (换弹管理器)                         │
│  - WeaponStateManager.as (武器状态管理器)                │
│  - ShootInitCore.as (武器初始化)                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                    数据层 (Data Layer)                   │
│  - parentRef (角色实例数据)                              │
│  - ItemUtil (物品管理工具)                               │
│  - EnhancedCooldownWheel (时间轮调度器)                  │
└─────────────────────────────────────────────────────────┘
```

### 模块职责划分

| 模块 | 文件路径 | 主要职责 |
|------|---------|---------|
| **射击核心** | ShootCore.as | 持续射击逻辑、射击条件检查、子弹发射 |
| **换弹管理** | ReloadManager.as | 换弹流程控制、弹匣消耗、UI更新 |
| **状态管理** | WeaponStateManager.as | 武器状态判断、换弹优先级决策 |
| **武器初始化** | ShootInitCore.as | 武器系统初始化、子弹属性生成 |
| **动画素材** | 双枪攻击.xml | 动画帧定义、视觉效果、时序控制 |

---

## 核心类说明

### 1. ShootCore.as

#### 职责
- 处理持续射击的核心逻辑
- 管理射击许可和后摇状态
- 与时间轮调度器集成

#### 关键方法

##### `continuousShoot(core, attackMode, shootSpeed, params): Boolean`
**位置**: ShootCore.as:53

**功能**: 执行一次射击并返回是否继续射击

**参数说明**:
```actionscript
core        : Object   - 自机对象（角色实例）
attackMode  : String   - 攻击模式（"手枪"/"手枪2"/"长枪"等）
shootSpeed  : Number   - 射击速度（毫秒）
params      : Object   - 配置参数对象（primaryParams或secondaryParams）
```

**关键逻辑**:
```actionscript
1. 检查射击许可标签 (man.射击许可标签)
   - 如果不允许射击，移除射击任务并返回false

2. 根据上下行状态设置角度偏移
   - 下行: offset = 30, 帧名 = "下射击"
   - 上行: offset = -30, 帧名 = "上射击"
   - 平行: offset = 0, 帧名 = "射击"

3. 更新子弹属性的角度偏移
   for (var i = 0; i < bulletAttrKeys.length; i++) {
       man[bulletAttrKeys[i]].角度偏移 = offset;
   }

4. 执行射击方法
   core[shootStateName] = core[shootMethodName](gunRef, bulletAttr)

5. 更新弹匣剩余子弹数并发布事件
   dispatcher.publish("updateBullet", ...)

6. 如果射击速度 > 300ms，添加后摇解除任务
```

**返回值**:
- `true`: 继续持续射击循环
- `false`: 停止射击（许可不足或其他原因）

##### `startShooting(core, protagonist, params): Void`
**位置**: ShootCore.as:201

**功能**: 启动持续射击任务

**关键流程**:
```actionscript
1. 快速检查
   if (core[params.shootingStateName] || protagonist.换弹标签) return;

2. 检查弹匣是否打空
   if (core[attackMode].value.shot >= core[magazineCapName]) {
       // 触发换弹
       if (protagonist.剩余弹匣数 > 0 || _root.控制目标 != core._name) {
           protagonist.开始换弹();
       }
       return;
   }

3. 执行首次射击
   if (ShootCore.continuousShoot(core, attackMode, interval, params)) {
       // 添加持续射击任务到时间轮
       core[params.taskName] = EnhancedCooldownWheel.I().addTask(
           ShootCore.continuousShoot,
           interval,
           0,
           core, attackMode, interval, params
       );
   }
```

#### 配置参数对象

##### primaryParams (主手配置)
```actionscript
{
    shootingStateName: "主手射击中",
    actionFlagName: "动作A",
    prefix: "",                        // 帧名后缀为空
    bulletAttrKeys: ["子弹属性"],
    shootBulletAttrKey: "子弹属性",
    gunPath: "枪.枪.装扮.枪口位置",
    taskName: "keepshooting",
    playerBulletField: "子弹数"
}
```

##### secondaryParams (副手配置)
```actionscript
{
    shootingStateName: "副手射击中",
    actionFlagName: "动作B",
    prefix: "2",                       // 帧名后缀为"2"
    bulletAttrKeys: ["子弹属性", "子弹属性2"],
    shootBulletAttrKey: "子弹属性2",
    gunPath: "枪2.枪.装扮.枪口位置",
    taskName: "keepshooting2",
    playerBulletField: "子弹数_2"
}
```

---

### 2. WeaponStateManager.as

#### 职责
- 跟踪主副手武器的实时状态
- 提供统一的状态判断接口
- 决定换弹优先级

#### 核心状态变量

```actionscript
私有变量:
  - mainNumber: Number        // 主手射击次数
  - subNumber: Number         // 副手射击次数
  - _mainIsEmpty: Boolean     // 主手弹匣是否打空
  - _subIsEmpty: Boolean      // 副手弹匣是否打空
  - _mainIsFull: Boolean      // 主手弹匣是否满弹
  - _subIsFull: Boolean       // 副手弹匣是否满弹
  - _isSameWeapon: Boolean    // 主副手是否为同种武器
```

#### 关键方法

##### `updateState(): Void`
**位置**: WeaponStateManager.as:62

**功能**: 刷新所有状态变量

**执行时机**:
- 构造函数初始化时
- 每次射击前
- 每次换弹后

**计算逻辑**:
```actionscript
mainNumber = parentRef[mainShotCountIndex].value.shot;
subNumber = parentRef[subShotCountIndex].value.shot;

_mainIsEmpty = mainNumber >= parentRef[mainMagCapacity];
_subIsEmpty = subNumber >= parentRef[subMagCapacity];

_mainIsFull = mainNumber == 0;
_subIsFull = subNumber == 0;

_isSameWeapon = (parentRef[mainWeaponType].name == parentRef[subWeaponType].name);
```

##### `shouldReloadMainFirst(isMainHandReloadable, isSubHandReloadable): Boolean`
**位置**: WeaponStateManager.as:115

**功能**: 决定是否应该优先换主手

**决策逻辑**:
```actionscript
优先换主手的条件（优先级从高到低）:

1. 主手无法换弹 → 返回false（不换主手）
   if (!isMainHandReloadable) return false;

2. 主手已空 → 返回true（优先换主手）
   if (_mainIsEmpty) return true;

3. 主手未满 && 副手满弹 → 返回true（优先换主手）
   if (!_mainIsFull && _subIsFull) return true;

4. 副手无法换弹 && 主手未满 → 返回true（换主手）
   if (!isSubHandReloadable && !_mainIsFull) return true;

5. 其他情况 → 返回false（换副手）
   return false;
```

##### `needsAnyReload(): Boolean`
**位置**: WeaponStateManager.as:183

**功能**: 判断是否需要任何换弹操作

**逻辑**:
```actionscript
return !(_mainIsFull && _subIsFull);
// 仅当两把枪都满弹时返回false
```

##### `canFinishMainHandReload(remainingMainMag, remainingSubMag): Boolean`
**位置**: WeaponStateManager.as:165

**功能**: 判断主手换弹后是否可以结束换弹流程

**逻辑**:
```actionscript
return remainingSubMag == 0 ||
       (_isSameWeapon ? _subIsFull : subNumber < parentRef[subMagCapacity]);

条件说明:
- 副手没有剩余弹匣 → 可以结束
- 同种武器: 副手已满弹 → 可以结束
- 异种武器: 副手未打空 → 可以结束
```

---

### 3. ReloadManager.as

#### 职责
- 管理换弹流程的启动、执行、结束
- 处理弹匣消耗和库存管理
- 更新UI显示

#### 关键方法

##### `startReload(target, parentRef, rootRef): Void`
**位置**: ReloadManager.as:22

**功能**: 开始换弹流程

**流程**:
```actionscript
1. 检查前置条件
   if (target.换弹标签 || parentRef[attackMode].value.shot == 0) {
       return;  // 已在换弹或弹匣已满
   }

2. 玩家控制角色
   if (rootRef.控制目标 === parentRef._name) {
       // 检查是否有可用弹匣
       if (ItemUtil.singleContain(target.使用弹匣名称, 1) != null) {
           target.gotoAndPlay("换弹匣");
       }
   }

3. AI角色
   else {
       target.gotoAndPlay("换弹匣");  // 直接进入换弹
   }
```

##### `reloadMagazine(target, parentRef, rootRef): Void`
**位置**: ReloadManager.as:48

**功能**: 执行换弹匣操作（在动画第113帧调用）

**流程**:
```actionscript
1. 重置射击次数
   parentRef[attackMode].value.shot = 0;

2. 玩家角色处理
   if (rootRef.控制目标 === parentRef._name) {
       // 消耗一个弹匣
       ItemUtil.singleSubmit(target.使用弹匣名称, 1);

       // 更新剩余弹匣数
       target.剩余弹匣数 = ItemUtil.getTotal(target.使用弹匣名称);

       // 检查弹匣耗尽
       if (target.剩余弹匣数 === 0) {
           rootRef.发布消息("弹匣耗尽！");
       }

       // 重置副武器发射数据
       parentRef.当前弹夹副武器已发射数 = 0;

       // 刷新UI
       ReloadManager.updateAmmoDisplay(target, parentRef, rootRef);
   }
```

##### `updateAmmoDisplay(target, parentRef, rootRef): Void`
**位置**: ReloadManager.as:89

**功能**: 更新玩家界面的弹药显示

**双枪模式UI更新**:
```actionscript
主手武器:
  ui.子弹数 = cost * (capacity - shot)
  ui.弹夹数 = target.主手剩余弹匣数

副手武器:
  ui.子弹数_2 = cost * (capacity - shot)
  ui.弹夹数_2 = target.副手剩余弹匣数

其中:
  cost = 子弹消耗系数（纵向弹为霰弹值，普通弹为1）
  capacity = 弹匣容量
  shot = 已射击次数
```

##### `createDualGunReloadStartFunction(target, parentRef, rootRef, stateManager): Function`
**位置**: ReloadManager.as:159

**功能**: 为双枪系统创建开始换弹函数

**决策流程**:
```actionscript
1. 检查换弹标签
   if (that.换弹标签) return;

2. 更新武器状态
   stateManager.updateState();

3. 检查是否需要换弹
   if (!stateManager.needsAnyReload()) return;

4. 玩家控制时的决策
   if (rootRef.控制目标 === parentRef._name) {
       var isMainHandReloadable = !!(ItemUtil.singleContain(that.主手使用弹匣名称, 1));
       var isSubHandReloadable = !!(ItemUtil.singleContain(that.副手使用弹匣名称, 1));

       if (stateManager.shouldReloadMainFirst(isMainHandReloadable, isSubHandReloadable)) {
           that.gotoAndPlay("主手换弹匣");
           return;
       } else {
           if (stateManager.shouldReloadSub() && isSubHandReloadable) {
               that.gotoAndPlay("副手换弹匣");
               return;
           }
       }
       that.gotoAndPlay("换弹结束");
   }

5. AI控制
   else {
       that.gotoAndPlay("主手换弹匣");
   }
```

---

### 4. ShootInitCore.as

#### 职责
- 初始化武器系统
- 生成子弹属性
- 绑定核心函数

#### 关键方法

##### `initWeaponSystem(target, parentRef, config): Void`
**位置**: ShootInitCore.as:40

**功能**: 通用武器系统初始化

**配置对象格式**:
```actionscript
config = {
    weaponType: String,        // "长枪"/"手枪"/"手枪2"/"双枪"
    isDualGun: Boolean,        // 是否为双枪模式
    weaponData: Array,         // 单武器模式下的属性数组
    mainWeaponData: Array,     // 双枪模式下主手属性
    subWeaponData: Array,      // 双枪模式下副手属性
    extraParams: Object        // 特殊属性（毒、吸血、暴击、斩杀等）
}
```

##### `generateBulletProps(parentRef, weaponType, weaponData, extraParams): Object`
**位置**: ShootInitCore.as:299

**功能**: 生成完整的子弹属性对象

**属性计算**:
```actionscript
基础属性:
  - 发射者: parentRef._name
  - 声音: weaponData.sound
  - 霰弹值: weaponData.split
  - 子弹散射度: weaponData.diffusion
  - 发射效果: weaponData.muzzle
  - 子弹种类: weaponData.bullet
  - 子弹速度: weaponData.velocity

计算属性:
  - 子弹威力 = basePower * 技能加成倍率 + 固定加成
    * 长枪: basePower * (1.5 + level * 0.03) + 30
    * 手枪: basePower * (1 + level * 0.015) + 20

  - 移动子弹散射度 = 散射度 + 10 - 移动射击等级

  - ammoCost = (子弹种类包含"纵向") ? 霰弹值 : 1

特殊属性（从extraParams或parentRef获取）:
  - 伤害类型
  - 魔法伤害属性
  - 毒
  - 吸血
  - 血量上限击溃
  - 暴击（函数）
  - 斩杀（百分比）
```

---

## 状态机流程

### 完整状态转换图

```
                    ┌──────────────┐
                    │   初始化     │
                    │ (空闲状态)   │
                    └──────┬───────┘
                           │
                           │ 玩家按下射击键
                           ▼
                    ┌──────────────────────┐
                    │   射击前置检查        │
                    │ ─────────────────    │
                    │ ✓ 是否在换弹中?      │
                    │ ✓ 是否有射击许可?    │
                    │ ✓ 弹匣是否有子弹?    │
                    └──────┬────┬──────────┘
                           │    │
                条件通过    │    │ 弹匣已空
                           │    └───────────────┐
                           ▼                    ▼
                    ┌─────────────┐     ┌──────────────┐
                    │  射击状态    │     │  检查弹匣库存 │
                    │             │     │ ──────────── │
                    │ 主手/副手    │     │ 主手弹匣数?  │
                    │ 射击动画     │     │ 副手弹匣数?  │
                    └──────┬──────┘     └──────┬───────┘
                           │                   │
                           │                   ├── 两手都无弹匣 ──┐
                           │                   │                  │
                           │                   ├── 主手需换弹 ────┤
                           │                   │                  │
                           │                   └── 副手需换弹 ────┤
                           │                                      │
                           ▼                                      ▼
                    ┌─────────────┐                    ┌────────────────┐
                    │ 持续射击循环 │                    │  换弹动画选择   │
                    │ ─────────── │                    │ ────────────── │
                    │ 每interval  │                    │ • 主手换弹匣   │
                    │ 执行一次    │                    │ • 副手换弹匣   │
                    │             │                    │ • 空枪状态     │
                    │ shot++      │                    └───────┬────────┘
                    │ 更新UI      │                            │
                    │ 检查弹匣    │                            │
                    └──────┬──────┘                            │
                           │                                   │
                           │ 弹匣打空或松开按键                 │
                           │                                   │
                           ▼                                   ▼
                    ┌─────────────┐                    ┌────────────────┐
                    │ 射击结束     │                    │  换弹流程      │
                    │             │                    │ ────────────── │
                    │ 清理定时器   │                    │ 帧60: 开始     │
                    │ 发送结束包   │                    │ 帧113: 执行    │
                    └──────┬──────┘                    │   shot = 0     │
                           │                           │   消耗弹匣     │
                           │                           │ 帧116: 结束    │
                           │                           └───────┬────────┘
                           │                                   │
                           │                                   │
                           └───────────┬───────────────────────┘
                                       │
                                       ▼
                                ┌──────────────┐
                                │   空闲状态    │
                                │ (等待下次输入)│
                                └──────────────┘
```

### 状态表

| 状态名称 | 动画帧标签 | 触发条件 | 持续时间 | 退出条件 |
|---------|-----------|---------|---------|---------|
| 空闲 | "空闲" | 初始/完成动作 | 无限 | 玩家输入 |
| 主手射击 | "射击"/"上射击"/"下射击" | 主手射击键 | 单次 | 动画结束 |
| 副手射击 | "射击2"/"上射击2"/"下射击2" | 副手射击键 | 单次 | 动画结束 |
| 持续射击 | 循环射击帧 | 全自动模式 | interval | 松开按键/弹匣空 |
| 换弹匣 | "换弹夹" (60-116帧) | 弹匣打空/手动换弹 | 约56帧 | 动画第116帧 |
| 空枪 | "空枪" (54-59帧) | 无弹匣且弹匣空 | 约5帧 | 动画结束 |
| 射击结束 | "结束" (48-53帧) | 射击完成 | 约5帧 | 动画结束 |

---

## 射击流程详解

### 1. 射击触发流程

#### 调用链
```
用户按下射击键
    ↓
target.主手开始射击() 或 target.副手开始射击()
[ShootInitCore.as:150/151 创建的闭包函数]
    ↓
前置检查:
  - if (parentRef[shootingFlagProp]) return;  // 正在射击
  - if (that.换弹标签) return;                // 正在换弹
    ↓
stateManager.updateState()  // 更新武器状态
    ↓
检查弹匣状态:
  var currentShot = parentRef[weaponType].value.shot;
  var currentHandIsEmpty = currentShot >= parentRef[magazineCapName];
    ↓
如果弹匣空:
  if (currentHandIsEmpty) {
      if (剩余弹匣数 > 0 || 非玩家控制) {
          that.开始换弹();
      }
      return;
  }
    ↓
如果弹匣有子弹:
  var continueShooting = that[continueMethodName](parentRef, weaponType, that[speedProp], that);
  if (continueShooting) {
      parentRef[timerProp] = EnhancedCooldownWheel.I().addTask(
          that[continueMethodName],
          that[speedProp],
          0,
          parentRef, weaponType, that[speedProp]
      );
  }
```

### 2. 单次射击执行

#### ShootCore.continuousShoot 执行细节

```actionscript
// 第1步: 检查射击许可
if (!man.射击许可标签) {
    core[shootStateName] = false;
    EnhancedCooldownWheel.I().removeTask(core[config.taskName]);
    return false;
}

// 第2步: 计算角度偏移和动画帧
var offset = 0;
var jumpFrameName = config.baseShootFrame;  // "射击" 或 "射击2"

if (isControlTarget && !core.上下移动射击) {
    if (core.下行) {
        offset = 30;
        jumpFrameName = "下射击" + config.prefix;  // "下射击" 或 "下射击2"
    } else if (core.上行) {
        offset = -30;
        jumpFrameName = "上射击" + config.prefix;  // "上射击" 或 "上射击2"
    }
}

// 第3步: 更新子弹属性
for (var i = 0; i < bulletAttrKeys.length; i++) {
    man[bulletAttrKeys[i]].角度偏移 = offset;
}

// 第4步: 发布射击事件
dispatcher.publish(attackMode + "射击");

// 第5步: 跳转到射击动画帧
man.gotoAndPlay(jumpFrameName);

// 第6步: 获取枪口位置并执行射击
var gunRef = man;
for (var p = 0; p < gunPath.length; p++) {
    gunRef = gunRef[gunPath[p]];
}
core[shootStateName] = core[shootMethodName](gunRef, bulletAttr);

// 第7步: 更新UI
var magazineRemaining = bulletAttr.ammoCost * (core[magazineCapName] - core[attackMode].value.shot);
dispatcher.publish("updateBullet", core, shootStateName, magazineRemaining, config.playerBulletField);

// 第8步: 如果射速较慢，添加后摇解除任务
if (shootSpeed > 300) {
    var existingId = core.taskLabel["结束射击后摇"];
    if (existingId) {
        wheel.removeTask(existingId);
    }
    core.taskLabel["结束射击后摇"] = wheel.addDelayedTask(300, function(target) {
        target.射击最大后摇中 = false;
    }, core);
}

// 第9步: 返回是否继续射击
return core[shootStateName];
```

### 3. 持续射击循环

#### 时间轮任务机制

```actionscript
// 添加任务
core[params.taskName] = EnhancedCooldownWheel.I().addTask(
    ShootCore.continuousShoot,  // 回调函数
    interval,                    // 执行间隔（射击速度）
    0,                          // 延迟启动时间（0表示立即）
    core,                       // 参数1
    attackMode,                 // 参数2
    interval,                   // 参数3
    params                      // 参数4
);

// 任务每隔 interval 毫秒执行一次 continuousShoot
// 直到 continuousShoot 返回 false 或任务被手动移除

// 移除任务
EnhancedCooldownWheel.I().removeTask(core[config.taskName]);
```

#### 停止射击的条件

1. **射击许可失效**: `!man.射击许可标签`
2. **弹匣打空**: `core[attackMode].value.shot >= core[magazineCapName]`
3. **玩家松开按键**: 动画层的 `onEnterFrame` 检测
4. **进入换弹状态**: `protagonist.换弹标签 = true`

### 4. 射击动画与脚本协同

#### 动画帧中的射击函数 (双枪攻击.xml)

```actionscript
// 帧1: 定义射击函数
function 射击() {
    if (_parent.手枪射击次数 < 弹夹容量) {
        if (枪_扣扳机 == true) {
            // 增加射击次数
            _parent.手枪射击次数++;

            // 更新UI
            if (_root.控制目标 == _parent._name) {
                _root.玩家信息界面.玩家必要信息界面.子弹数 = 弹夹容量 - _parent.手枪射击次数;
            }

            // 调用全局子弹生成函数
            _root.子弹区域shoot(
                声音, 霰弹值, 子弹散射度, 发射效果,
                子弹种类, 子弹威力, 子弹速度, Z轴攻击范围,
                击中地图效果, _parent._name, shootX, shootY,
                _parent.Z轴坐标, 子弹敌我属性, 击倒率, 击中后子弹的效果
            );

            // 单发武器计时
            if (手枪是否单发 == true) {
                _parent.单发枪计时();
            }

            // 跳转到对应射击帧
            if (Key.isDown(_parent.下键)) {
                gotoAndStop("下射击");
            } else if (Key.isDown(_parent.上键)) {
                gotoAndStop("上射击");
            } else {
                gotoAndStop("射击");
            }
            play();
        }
    }
}

// 类似的 射击_2() 函数处理副手
```

---

## 换弹流程详解

### 1. 换弹触发条件

#### 自动触发
```actionscript
// ShootCore.as:217
if (core[attackMode].value.shot >= core[magazineCapName]) {
    if (protagonist.剩余弹匣数 > 0 || _root.控制目标 != core._name) {
        protagonist.开始换弹();
    }
}
```

#### 双枪特殊规则 (ShootInitCore.as:234)
```actionscript
var currentHandIsEmpty = currentShot >= parentRef[magazineCapName];

if (currentHandIsEmpty) {
    if (剩余弹匣数 > 0 || _root.控制目标 != parentRef._name) {
        that.开始换弹();
    }
    return;  // 无论是否有弹匣，都不能继续射击
}
```

#### 手动触发
- 玩家按下换弹键 → 设置 `_parent.强制换弹夹 = true`
- 动画层检测到强制换弹标志 → 调用 `换弹夹()` 函数

### 2. 单武器换弹流程

```
ReloadManager.startReload()
    ↓
检查前置条件:
  - if (target.换弹标签) return;              // 已在换弹
  - if (parentRef[attackMode].value.shot == 0) return;  // 弹匣已满
    ↓
玩家控制角色:
  if (ItemUtil.singleContain(target.使用弹匣名称, 1) != null) {
      target.gotoAndPlay("换弹匣");
  }
    ↓
动画跳转到第60帧 "换弹夹"
    ↓
帧60脚本执行:
  _root.client.sendData(DataPackage.射击结束());
  _root.client.sendData(DataPackage.换弹夹());
  delete this.onEnterFrame;
  _parent.强制换弹夹 = false;
  play();
    ↓
动画播放到第113帧
    ↓
帧113脚本调用 ReloadManager.reloadMagazine():
  1. parentRef[attackMode].value.shot = 0;
  2. ItemUtil.singleSubmit(target.使用弹匣名称, 1);  // 消耗弹匣
  3. target.剩余弹匣数 = ItemUtil.getTotal(target.使用弹匣名称);
  4. ReloadManager.updateAmmoDisplay(target, parentRef, rootRef);
    ↓
动画播放到第116帧
    ↓
帧116脚本执行:
  _parent.动画完毕();  // 返回空闲状态
```

### 3. 双枪换弹流程

#### 3.1 决策阶段

```
target.开始换弹()
[ReloadManager.createDualGunReloadStartFunction 创建的闭包]
    ↓
检查前置条件:
  if (that.换弹标签) return;
    ↓
stateManager.updateState()
    ↓
检查是否需要换弹:
  if (!stateManager.needsAnyReload()) return;
    ↓
获取弹匣库存:
  var isMainHandReloadable = !!(ItemUtil.singleContain(that.主手使用弹匣名称, 1));
  var isSubHandReloadable = !!(ItemUtil.singleContain(that.副手使用弹匣名称, 1));
    ↓
决策优先级:
  if (stateManager.shouldReloadMainFirst(isMainHandReloadable, isSubHandReloadable)) {
      that.gotoAndPlay("主手换弹匣");
  } else if (stateManager.shouldReloadSub() && isSubHandReloadable) {
      that.gotoAndPlay("副手换弹匣");
  } else {
      that.gotoAndPlay("换弹结束");
  }
```

#### 3.2 主手换弹执行

```
target.主手换弹匣()
[ReloadManager.createHandReloadFunction 创建的闭包]
    ↓
重置射击次数:
  parentRef["手枪"].value.shot = 0;
    ↓
消耗弹匣:
  ItemUtil.singleSubmit(that.主手使用弹匣名称, 1);
    ↓
更新两手的弹匣数量:
  that.主手剩余弹匣数 = ItemUtil.getTotal(that.主手使用弹匣名称);
  that.副手剩余弹匣数 = ItemUtil.getTotal(that.副手使用弹匣名称);
    ↓
检查弹匣耗尽:
  if (that.主手剩余弹匣数 === 0) {
      rootRef.发布消息("弹匣耗尽！");
  }
    ↓
更新UI:
  ReloadManager.updateAmmoDisplay(that, parentRef, rootRef);
    ↓
更新状态:
  stateManager.updateState();
    ↓
检查是否可以结束换弹:
  if (stateManager.canFinishMainHandReload(that.主手剩余弹匣数, that.副手剩余弹匣数)) {
      that.gotoAndPlay("换弹结束");
  }
  // 否则可能需要继续换副手
```

#### 3.3 副手换弹执行
（流程与主手类似，使用"手枪2"相关属性）

### 4. 换弹优先级决策表

| 主手状态 | 副手状态 | 主手弹匣 | 副手弹匣 | 换弹决策 |
|---------|---------|---------|---------|---------|
| 空 | 空 | 有 | 有 | 主手优先 |
| 空 | 空 | 有 | 无 | 换主手 |
| 空 | 空 | 无 | 有 | 换副手 |
| 空 | 空 | 无 | 无 | 空枪状态 |
| 空 | 未满 | 有 | - | 换主手 |
| 未满 | 空 | - | 有 | 换副手 |
| 未满 | 满 | 有 | - | 换主手 |
| 满 | 未满 | - | 有 | 换副手 |
| 满 | 满 | - | - | 不换弹 |

#### 同种武器特殊规则
```actionscript
// WeaponStateManager.as:97
if (_isSameWeapon && !_mainIsEmpty && !_subIsEmpty) {
    return false;  // 两手都有子弹，不换弹
}

// 同种武器只有在任一手打空时才触发换弹
```

### 5. 动画层换弹脚本 (旧版实现)

#### 双枪攻击.xml 中的换弹夹函数
```actionscript
function 换弹夹() {
    delete this.onEnterFrame;
    clearInterval(keepshooting);
    clearInterval(keepshooting_2);

    if (_root.控制目标 == _parent._name) {
        枪可换弹夹 = false;
        枪2可换弹夹 = false;

        // 遍历物品栏检查弹匣
        for (var i = 0; i < _root.物品栏总数; i++) {
            if (_root.物品栏[i][0] == 使用弹夹名称) {
                if (_root.物品栏[i][1] >= 1) {
                    枪弹夹值 = i;
                    枪可换弹夹 = true;
                } else {
                    _root.发布消息("一只枪弹夹耗尽！");
                    _root.物品栏[i] = ["空", 0, 0];
                    _root.排列物品图标();
                }
            }

            if (_root.物品栏[i][0] == 使用弹夹名称_2) {
                if (_root.物品栏[i][1] >= 1) {
                    枪2弹夹值 = i;
                    枪2可换弹夹 = true;
                } else {
                    _root.发布消息("另一只枪弹夹耗尽！");
                    _root.物品栏[i] = ["空", 0, 0];
                    _root.排列物品图标();
                }
            }

            if (枪可换弹夹 && 枪2可换弹夹) break;
        }

        // 根据弹匣情况决定动作
        if (枪可换弹夹 || 枪2可换弹夹) {
            gotoAndStop("换弹夹");
            play();
        } else if (!枪可换弹夹 && !枪2可换弹夹 &&
                   _parent.手枪射击次数 >= 弹夹容量 &&
                   _parent.手枪2射击次数 >= 弹夹容量_2) {
            gotoAndStop("空枪");
            play();
        }
    } else {
        // AI角色直接重置
        _parent.手枪射击次数 = 0;
        _parent.手枪2射击次数 = 0;
        gotoAndStop("换弹夹");
        play();
    }
}

// 帧113: 实际消耗弹匣
if (_root.控制目标 == _parent._name) {
    if (枪可换弹夹 == true) {
        _root.物品栏[枪弹夹值][1]--;
        _parent.手枪射击次数 = 0;
    }
    if (枪2可换弹夹 == true) {
        _root.物品栏[枪2弹夹值][1]--;
        _root.排列物品图标();
        _parent.手枪2射击次数 = 0;
    }
}
```

**注意**: 这是动画层的旧实现，新版已迁移到 ReloadManager 中管理。

---

## 动画层集成

### 1. 动画帧布局

#### 主时间轴结构
```
帧标签           | 帧号  | 功能
─────────────────┼───────┼──────────────────────
(初始化)         | 0-1   | 变量初始化
射击             | 2-8   | 主手平射
上射击           | 9-16  | 主手上射
下射击           | 17-24 | 主手下射
射击2            | 25-31 | 副手平射
上射击2          | 32-39 | 副手上射
下射击2          | 40-47 | 副手下射
结束             | 48-53 | 射击结束
空枪             | 54-59 | 无弹匣状态
换弹夹           | 60-112| 换弹动画
(换弹执行)       | 113   | 消耗弹匣并重置
(换弹结束)       | 114-116| 完成换弹
```

### 2. 关键帧脚本

#### 帧0: 变量初始化
```actionscript
枪_扣扳机 = false;
枪2_扣扳机 = false;
```

#### 帧1: 核心逻辑初始化
```actionscript
// 从 _parent.手枪属性 和 _parent.手枪2属性 读取配置
射击速度 = _parent.手枪属性.interval;
弹夹容量 = _parent.手枪属性.capacity;
使用弹夹名称 = _parent.手枪属性.clipname;
// ... 更多属性

// 计算枪口位置
var myPoint = {x: this.枪.枪.装扮.枪口位置._x, y: this.枪.枪.装扮.枪口位置._y};
this.枪.枪.装扮.localToGlobal(myPoint);
_root.gameworld.globalToLocal(myPoint);
shootX = myPoint.x;
shootY = myPoint.y;

// 检查剩余弹匣
剩余弹夹数 = 检查下是否有弹夹(使用弹夹名称);
剩余弹夹数_2 = 检查下是否有弹夹(使用弹夹名称_2);

// 设置持续射击循环
keepshooting = setInterval(射击, 射击速度);
keepshooting_2 = setInterval(射击_2, 射击速度_2);

// onEnterFrame 监听
this.onEnterFrame = function() {
    // 检查双手都打空
    if (_parent.手枪射击次数 >= 弹夹容量 && _parent.手枪2射击次数 >= 弹夹容量_2) {
        换弹夹();
    }

    // 检查玩家是否松开按键
    if (_parent.操控编号 != -1 &&
        _root.控制目标全自动 == false &&
        !Key.isDown(_parent.A键) &&
        !Key.isDown(_parent.B键)) {
        clearInterval(keepshooting);
        clearInterval(keepshooting_2);
        gotoAndStop("结束");
    }
};
```

#### 帧60: 换弹开始
```actionscript
_root.client.sendData(DataPackage.射击结束());
_root.client.sendData(DataPackage.换弹夹());
联机_长枪是否射击 = true;
delete this.onEnterFrame;
_parent.强制换弹夹 = false;
play();
```

#### 帧113: 换弹执行
```actionscript
if (_root.控制目标 == _parent._name) {
    if (枪可换弹夹 == true) {
        _root.物品栏[枪弹夹值][1]--;
        _parent.手枪射击次数 = 0;
    }
    if (枪2可换弹夹 == true) {
        _root.物品栏[枪2弹夹值][1]--;
        _root.排列物品图标();
        _parent.手枪2射击次数 = 0;
    }
}
```

#### 帧116: 换弹结束
```actionscript
_parent.动画完毕();
```

### 3. 动画层与逻辑层的交互

#### 逻辑层 → 动画层
```actionscript
// ShootCore.as:125
man.gotoAndPlay(jumpFrameName);  // 跳转到射击动画帧

// ReloadManager.as:34
target.gotoAndPlay("换弹匣");    // 跳转到换弹动画

// ReloadManager.as:80
target.gotoAndStop("空闲");      // 返回空闲状态
```

#### 动画层 → 逻辑层
```actionscript
// 双枪攻击.xml:320
换弹夹();  // 调用动画层定义的换弹函数（旧版）

// 新版应该调用:
target.开始换弹();  // 调用 ReloadManager.startReload
```

### 4. 网络同步点

```actionscript
// 射击结束时
_root.client.sendData(DataPackage.射击结束());

// 换弹开始时
_root.client.sendData(DataPackage.换弹夹());

// 这些调用发生在动画的关键帧，确保网络同步
```

---

## 关键数据结构

### 1. 角色对象 (parentRef)

```actionscript
parentRef = {
    _name: String,              // 角色唯一标识
    攻击模式: String,           // "手枪"/"手枪2"/"长枪"/"双枪"
    是否为敌人: Boolean,
    操控编号: Number,

    // 武器属性
    手枪属性: WeaponData,
    手枪2属性: WeaponData,
    长枪属性: WeaponData,

    // 弹匣容量
    手枪弹匣容量: Number,
    手枪2弹匣容量: Number,
    长枪弹匣容量: Number,

    // 武器实例（包含射击计数）
    手枪: {
        name: String,
        value: {
            shot: Number        // 当前弹匣已射击次数
        }
    },
    手枪2: { ... },
    长枪: { ... },

    // 状态标志
    下行: Boolean,
    上行: Boolean,
    上下移动射击: Boolean,

    // 被动技能
    被动技能: {
        枪械攻击: {
            启用: Boolean,
            等级: Number
        },
        移动射击: {
            启用: Boolean,
            等级: Number
        }
    },

    // 额外加成
    长枪额外攻击加成倍率: Number,
    短枪额外攻击加成倍率: Number,

    // 特殊属性
    手枪伤害类型: String,
    手枪魔法伤害属性: Object,
    手枪毒: Object,
    手枪吸血: Number,
    手枪击溃: Number,
    手枪暴击: Object,
    手枪斩杀: Number,

    手枪2伤害类型: String,
    // ... 副手特殊属性

    // 副武器相关
    当前弹夹副武器已发射数: Number,

    // 调度器
    dispatcher: EventDispatcher
}
```

### 2. 武器数据 (WeaponData)

```actionscript
WeaponData = {
    interval: Number,       // 射击间隔（毫秒）
    capacity: Number,       // 弹匣容量
    clipname: String,       // 弹匣物品名称
    singleshoot: Boolean,   // 是否单发
    sound: String,          // 射击音效
    split: Number,          // 霰弹值
    diffusion: Number,      // 子弹散射度
    muzzle: String,         // 枪口效果
    bullet: String,         // 子弹种类
    power: Number,          // 基础威力
    velocity: Number,       // 子弹速度
    bullethit: String,      // 击中地图效果
    bulletsize: Number,     // Z轴攻击范围
    impact: Number,         // 击倒率
    targethit: String       // 击中目标效果
}
```

### 3. 子弹属性对象 (BulletProps)

```actionscript
BulletProps = {
    // 基础属性
    发射者: String,
    声音: String,
    霰弹值: Number,
    子弹散射度: Number,
    站立子弹散射度: Number,
    移动子弹散射度: Number,
    发射效果: String,
    子弹种类: String,
    ammoCost: Number,           // 子弹消耗系数
    子弹速度: Number,
    击中地图效果: String,
    Z轴攻击范围: Number,
    击倒率: Number,
    击中后子弹的效果: String,
    子弹威力: Number,            // 计算后的最终威力
    角度偏移: Number,            // 动态设置

    // 特殊属性（可选）
    伤害类型: String,
    魔法伤害属性: Object,
    毒: Object,
    吸血: Number,
    血量上限击溃: Number,
    暴击: Function,             // 暴击判断函数
    斩杀: Number                // 斩杀百分比
}
```

### 4. 目标对象 (target / protagonist)

```actionscript
target = {
    // 基础属性
    射击速度: Number,
    使用弹匣名称: String,
    是否单发: Boolean,
    剩余弹匣数: Number,

    // 双枪模式额外属性
    主手射击速度: Number,
    主手使用弹匣名称: String,
    主手是否单发: Boolean,
    主手剩余弹匣数: Number,

    副手射击速度: Number,
    副手使用弹匣名称: String,
    副手是否单发: Boolean,
    副手剩余弹匣数: Number,

    // 子弹属性
    子弹属性: BulletProps,
    子弹属性2: BulletProps,      // 双枪副手

    // 状态标志
    换弹标签: Boolean,
    射击许可标签: Boolean,

    // 任务ID
    keepshooting: Number,
    keepshooting2: Number,
    taskLabel: Object,            // 任务标签映射

    // 武器状态管理器（双枪）
    weaponStateManager: WeaponStateManager,

    // 核心函数（由 ShootInitCore 绑定）
    开始射击: Function,
    主手开始射击: Function,
    副手开始射击: Function,
    主手持续射击: Function,
    副手持续射击: Function,
    开始换弹: Function,
    换弹匣: Function,
    主手换弹匣: Function,
    副手换弹匣: Function,
    结束换弹: Function,
    刷新弹匣数显示: Function
}
```

### 5. 配置参数对象 (params)

```actionscript
params = {
    shootingStateName: String,      // "主手射击中" 或 "副手射击中"
    actionFlagName: String,         // "动作A" 或 "动作B"
    prefix: String,                 // "" 或 "2"
    bulletAttrKeys: Array,          // ["子弹属性"] 或 ["子弹属性", "子弹属性2"]
    shootBulletAttrKey: String,     // "子弹属性" 或 "子弹属性2"
    gunPath: String,                // "枪.枪.装扮.枪口位置" 或 "枪2.枪.装扮.枪口位置"
    taskName: String,               // "keepshooting" 或 "keepshooting2"
    playerBulletField: String       // "子弹数" 或 "子弹数_2"
}
```

---

## 配置与扩展点

### 1. 武器初始化配置

#### 单武器初始化
```actionscript
// 长枪
ShootInitCore.initLongGun(target, parentRef);

// 手枪
ShootInitCore.initPistol(target, parentRef);

// 手枪2
ShootInitCore.initPistol2(target, parentRef);
```

#### 双枪初始化
```actionscript
ShootInitCore.initDualGun(target, parentRef);

// 自动处理:
// - 创建 WeaponStateManager
// - 初始化主副手属性
// - 生成两个子弹属性对象
// - 绑定主副手射击和换弹函数
```

### 2. 自定义武器类型

#### 扩展新武器步骤
```actionscript
// 1. 在 parentRef 中添加武器属性
parentRef.新武器属性 = {
    interval: 500,
    capacity: 30,
    clipname: "新武器弹匣",
    // ... 其他属性
};

// 2. 添加弹匣容量
parentRef.新武器弹匣容量 = parentRef.新武器属性.capacity;

// 3. 创建武器实例
parentRef.新武器 = {
    name: "新武器名称",
    value: { shot: 0 }
};

// 4. 在 ShootInitCore 中创建初始化方法
public static function initNewWeapon(target:MovieClip, parentRef:Object):Void {
    var config:Object = {
        weaponType: "新武器",
        weaponData: parentRef.新武器属性,
        isDualGun: false,
        extraParams: {}
    };
    ShootInitCore.initWeaponSystem(target, parentRef, config);
}

// 5. 在动画层调用
ShootInitCore.initNewWeapon(this, _parent);
```

### 3. 特殊子弹属性扩展

#### 添加自定义弹道效果
```actionscript
// 在 generateBulletProps 中扩展
bulletProps.自定义属性 = extraParams.自定义属性 || parentRef[weaponType + "自定义属性"];

// 初始化时传入
var extraParams = {
    自定义属性: {
        效果类型: "追踪",
        追踪范围: 500,
        追踪速度: 1.5
    }
};
```

### 4. 暴击系统扩展

#### 当前支持的暴击类型
```actionscript
// 1. 固定概率暴击
暴击: 20  // 20%暴击率，1.5倍伤害

// 2. 满血暴击
暴击: "满血暴击"  // 目标满血时暴击

// 3. 自定义暴击函数（扩展点）
暴击: function(当前子弹:Object):Number {
    // 自定义判断逻辑
    if (某种条件) {
        return 2.0;  // 2倍伤害
    }
    return 1.0;
}
```

### 5. UI显示自定义

#### 修改弹药显示格式
```actionscript
// ReloadManager.as:144
ui[w.uiBullet] = cost * remaining;

// 可以修改为:
ui[w.uiBullet] = formatBulletDisplay(cost * remaining);

function formatBulletDisplay(num:Number):String {
    if (num >= 1000) return (num / 1000).toFixed(1) + "K";
    return String(num);
}
```

### 6. 射击速度调整

#### 动态修改射击间隔
```actionscript
// 在射击前调整
target.射击速度 = baseInterval * 技能加成倍率;

// 或在 continuousShoot 中动态计算
var shootSpeed = protagonist.射击速度 * (1 - 攻速加成百分比);
```

### 7. 换弹动画自定义

#### 修改换弹动画帧
```xml
<!-- 双枪攻击.xml -->
<DOMFrame index="60" name="换弹夹" labelType="name" keyMode="9728">
  <!-- 自定义换弹动画素材 -->
</DOMFrame>

<!-- 调整换弹持续时间 -->
<DOMFrame index="60" duration="40" keyMode="9728">
  <!-- 从60帧到100帧完成换弹 -->
</DOMFrame>

<!-- 相应调整执行帧 -->
<DOMFrame index="90" keyMode="9728">
  <!-- 换弹执行脚本移到90帧 -->
</DOMFrame>
```

---

## 已知问题与优化建议

### 1. 架构层面

#### 问题: 动画层与逻辑层耦合
**现状**:
- 动画XML中仍有部分旧的换弹逻辑（`换弹夹()` 函数）
- 与新的 `ReloadManager` 可能产生冲突

**建议**:
```actionscript
// 完全移除动画层的换弹逻辑，统一使用:
target.开始换弹();  // ReloadManager.startReload
target.换弹匣();    // ReloadManager.reloadMagazine

// 在动画帧60改为:
_root.client.sendData(DataPackage.换弹夹());
// 不再调用本地换弹夹()函数
```

#### 问题: 状态管理分散
**现状**:
- `parentRef[weaponType].value.shot` 在多处修改
- 动画层和逻辑层都在更新状态

**建议**:
```actionscript
// 创建统一的状态管理接口
class WeaponStateController {
    public function incrementShot(weaponType:String):Void {
        parentRef[weaponType].value.shot++;
        // 自动触发UI更新事件
        dispatcher.publish("shotCountChanged", weaponType, parentRef[weaponType].value.shot);
    }

    public function resetShot(weaponType:String):Void {
        parentRef[weaponType].value.shot = 0;
        dispatcher.publish("shotCountReset", weaponType);
    }
}
```

### 2. 性能优化

#### 问题: 每帧检查弹匣状态
**现状**:
```actionscript
this.onEnterFrame = function() {
    if (_parent.手枪射击次数 >= 弹夹容量 && _parent.手枪2射击次数 >= 弹夹容量_2) {
        换弹夹();
    }
}
```

**建议**:
```actionscript
// 在射击时立即检查，不需要 onEnterFrame 轮询
// ShootCore.as 中已经实现了这一点
if (core[attackMode].value.shot >= core[magazineCapName]) {
    protagonist.开始换弹();
}

// 移除动画层的 onEnterFrame 检查
```

#### 问题: 缓存未充分利用
**现状**: 每次射击都重新解析枪口路径

**建议**:
```actionscript
// ShootCore.as:71 已实现缓存
gunPathArray: params.gunPath.split(".")

// 确保其他地方也使用缓存
// 避免重复的 split() 操作
```

### 3. 代码可维护性

#### 问题: 魔法字符串
**现状**:
```actionscript
"主手射击中"
"副手射击中"
"动作A"
"动作B"
"keepshooting"
"keepshooting2"
```

**建议**:
```actionscript
// 创建常量类
class ShootConstants {
    public static var MAIN_SHOOTING_STATE:String = "主手射击中";
    public static var SUB_SHOOTING_STATE:String = "副手射击中";
    public static var ACTION_FLAG_A:String = "动作A";
    public static var ACTION_FLAG_B:String = "动作B";
    public static var MAIN_TASK_NAME:String = "keepshooting";
    public static var SUB_TASK_NAME:String = "keepshooting2";
}

// 使用时:
shootingStateName: ShootConstants.MAIN_SHOOTING_STATE
```

#### 问题: 注释不足
**现状**: 部分关键逻辑缺少中文注释

**建议**:
- 为所有公共方法添加详细的 JSDoc 注释
- 关键算法添加行内注释说明
- 复杂的状态转换添加流程图注释

### 4. 功能扩展

#### 建议: 添加换弹取消机制
```actionscript
public function cancelReload(target:MovieClip):Void {
    if (target.换弹标签) {
        target.换弹标签 = false;
        target.gotoAndStop("空闲");
        // 可选: 部分返还弹匣
    }
}
```

#### 建议: 快速换弹技能支持
```actionscript
public function quickReload(target:MovieClip, parentRef:Object):Void {
    var quickReloadLevel = parentRef.被动技能.快速换弹.等级;
    var reloadSpeedMultiplier = 1 + quickReloadLevel * 0.1;  // 每级10%加速

    // 动态调整动画播放速度
    // 或跳过部分换弹帧
}
```

#### 建议: 弹匣类型系统
```actionscript
public function getMagazineType(clipname:String):String {
    // 根据弹匣名称返回类型
    if (clipname.indexOf("穿甲") >= 0) return "穿甲弹";
    if (clipname.indexOf("高爆") >= 0) return "高爆弹";
    return "普通弹";
}

// 在生成子弹属性时应用不同效果
```

### 5. 网络同步

#### 问题: 换弹同步时机
**现状**: 在动画第60帧发送换弹包

**建议**:
```actionscript
// 在换弹决策时就发送，不要等到动画帧
public static function startReload(...):Void {
    // 检查通过后立即同步
    _root.client.sendData(DataPackage.开始换弹(attackMode));

    target.gotoAndPlay("换弹匣");
}

// 避免网络延迟导致其他玩家看到的换弹延后
```

#### 建议: 添加射击次数同步
```actionscript
// 定期同步射击计数，防止客户端不一致
if (shotCount % 5 == 0) {  // 每5发同步一次
    _root.client.sendData(DataPackage.同步弹匣状态(weaponType, shotCount));
}
```

### 6. 调试支持

#### 建议: 添加调试模式
```actionscript
class ShootDebugger {
    public static var DEBUG_MODE:Boolean = false;

    public static function log(message:String):Void {
        if (DEBUG_MODE) {
            _root.发布消息("[射击系统] " + message);
        }
    }

    public static function logState(stateManager:WeaponStateManager):Void {
        if (DEBUG_MODE) {
            log("主手: " + (stateManager.mainIsEmpty ? "空" : "有弹") +
                " 副手: " + (stateManager.subIsEmpty ? "空" : "有弹"));
        }
    }
}

// 使用:
ShootDebugger.log("开始射击: " + attackMode);
ShootDebugger.logState(stateManager);
```

### 7. 错误处理

#### 问题: 缺少边界检查
**建议**:
```actionscript
public static function continuousShoot(...):Boolean {
    // 添加安全检查
    if (!core || !man) {
        _root.发布消息("射击错误: 对象引用丢失");
        return false;
    }

    if (!man[bulletAttrKey]) {
        _root.发布消息("射击错误: 子弹属性未初始化");
        return false;
    }

    // 原有逻辑...
}
```

### 8. 测试建议

#### 单元测试用例
```actionscript
// 测试换弹优先级
function testReloadPriority():Void {
    // 场景1: 主手空，副手满
    parentRef.手枪.value.shot = 30;  // 假设容量30
    parentRef.手枪2.value.shot = 0;
    stateManager.updateState();
    assert(stateManager.shouldReloadMainFirst(true, true) == true);

    // 场景2: 主手满，副手空
    parentRef.手枪.value.shot = 0;
    parentRef.手枪2.value.shot = 30;
    stateManager.updateState();
    assert(stateManager.shouldReloadMainFirst(true, true) == false);

    // 更多测试...
}
```

---

## 附录

### A. 完整调用时序图

```
玩家按下射击键
    │
    ├─> 主手射击
    │   └─> target.主手开始射击()
    │       └─> ShootCore.continuousShoot(...)
    │           ├─> man.gotoAndPlay("射击")
    │           ├─> core[shootMethod](gunRef, bulletAttr)
    │           │   └─> _root.子弹区域shoot(...)
    │           ├─> dispatcher.publish("updateBullet", ...)
    │           │   └─> UI更新
    │           └─> EnhancedCooldownWheel.addTask(...)
    │               └─> 每interval ms执行一次 continuousShoot
    │
    └─> 副手射击（流程类似）

弹匣打空触发
    │
    └─> target.开始换弹()
        └─> ReloadManager.startReload(...)
            ├─> ItemUtil.singleContain(弹匣名称, 1)
            └─> target.gotoAndPlay("换弹匣")
                │
                ├─> 动画帧60: 网络同步
                │   └─> _root.client.sendData(DataPackage.换弹夹())
                │
                ├─> 动画帧113: 执行换弹
                │   └─> target.换弹匣()
                │       └─> ReloadManager.reloadMagazine(...)
                │           ├─> shot = 0
                │           ├─> ItemUtil.singleSubmit(弹匣, 1)
                │           └─> ReloadManager.updateAmmoDisplay(...)
                │
                └─> 动画帧116: 结束
                    └─> _parent.动画完毕()
                        └─> target.gotoAndStop("空闲")
```

### B. 关键文件路径索引

```
scripts\类定义\org\flashNight\arki\unit\Action\Shoot\
├── ShootCore.as              (射击核心)
├── ShootInitCore.as          (武器初始化)
├── ReloadManager.as          (换弹管理)
├── WeaponStateManager.as     (状态管理)
└── 双枪系统技术文档.md        (本文档)

flashswf\arts\things0\LIBRARY\主角动画层\
└── 双枪攻击.xml               (动画素材与脚本)

scripts\类定义\org\flashNight\neur\ScheduleTimer\
└── EnhancedCooldownWheel.as  (时间轮调度器)

scripts\类定义\org\flashNight\arki\item\
└── ItemUtil.as               (物品工具类)
```

### C. 术语表

| 术语 | 英文 | 说明 |
|------|------|------|
| 弹匣容量 | Magazine Capacity | 每个弹匣可容纳的子弹数 |
| 射击次数 | Shot Count | 当前弹匣已发射的子弹数 |
| 剩余弹匣数 | Remaining Magazines | 库存中的弹匣数量 |
| 霰弹值 | Split | 单次射击发射的子弹数（散弹枪） |
| 子弹散射度 | Diffusion | 子弹随机偏移角度 |
| 击倒率 | Impact | 击倒目标的概率 |
| 斩杀 | Execute | 低血量目标秒杀机制 |
| 击溃 | Crush | 基于血量上限的额外伤害 |
| 后摇 | Recovery | 射击后的硬直时间 |
| 时间轮 | Timing Wheel | 高效的定时任务调度器 |

### D. 版本历史

| 版本 | 日期 | 变更说明 |
|------|------|---------|
| 1.0 | 2025-10-26 | 初始版本，完整记录当前系统架构 |

---

## 联系与反馈

如需对本文档提出建议或发现错误，请联系开发团队。

**文档维护**: 开发团队
**最后更新**: 2025-10-26
