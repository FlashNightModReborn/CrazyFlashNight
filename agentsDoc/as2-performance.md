# AS2 性能特性与优化指引

> 本项目在 `scripts/优化随笔/` 下积累了 24 篇深度 AS2 性能研究。
> 本文档提供分类索引与关键结论摘要，用于在性能敏感场景下快速查阅。

---

## 1. 索引：按主题分类

### 位运算与底层优化
| 文件 | 主题 |
|------|------|
| `AS2 中 Number 类型的位运算与内存优化.md` | Number 类型的位运算特性 |
| `位运算加速.md` | 位运算替代常规算术的加速方案 |
| `字符串下的位运算表现.md` | 字符串与位运算的交互性能 |
| `ActionScript 2 (AS2) 分支预测性能试验技术总结.md` | 分支预测对性能的影响 |
| `分支预测视角下的优化指引.md` | 基于分支预测的优化决策指引 |
| `ActionScript 2  标志位组合算法性能微基准实验报告.md` | 标志位组合算法的基准测试 |
| `ActionScript 2 中 NaN-Boxing 技术评估报告.md` | NaN-Boxing 技术可行性评估 |

### 循环与迭代
| 文件 | 主题 |
|------|------|
| `循环展开优化因子的选择测试.md` | 循环展开的最优因子 |
| `for in 循环性能优化尝试.md` | for...in 循环的性能特性 |
| `ActionScript 2.0 for...in 循环中动态修改对象属性的安全性及行为特性研究报告.md` | for...in 中动态修改的安全性 |
| `数组填充移除性能测试评估.md` | 数组操作的性能评估 |

### 运算与表达式
| 文件 | 主题 |
|------|------|
| `运算符性能测试评估.md` | 各运算符的性能对比 |
| `逻辑运算符性能测试评估.md` | 逻辑运算符的性能特性 |
| `交换变量的性能评估.md` | 变量交换的最优方式 |
| `对降低abs取绝对值操作开销的探索.md` | Math.abs 替代方案 |
| `对降低floor取整操作开销的探索.md` | Math.floor 替代方案 |

### 字符串与对象
| 文件 | 主题 |
|------|------|
| `字符串性能评估.md` | 字符串操作的性能特性 |
| `分析 AS2 中对象属性的哈希函数实现.md` | 对象属性哈希机制分析 |
| `原型链注入的性能评估.md` | 原型链注入对性能的影响 |

### 运行时与内存
| 文件 | 主题 |
|------|------|
| `EnterFrame事件的性能分析报告.md` | EnterFrame 事件的性能开销 |
| `as2环境下的缓存命中优化评估.md` | 缓存命中率优化策略 |
| `异常兜底措施的性能评估与优化.md` | try-catch 的性能影响 |

### AVM1 字节码与编译器行为
| 文件 | 主题 |
|------|------|
| `scripts/类定义/org/flashNight/naki/Sort/evalorder.md` | AS2 求值顺序规则文档 |
| `scripts/类定义/org/flashNight/naki/Sort/EvalOrderTest.as` | 求值顺序验证测试 |
| `scripts/类定义/org/flashNight/naki/Sort/TimSort.as`（文件头注释）| AVM1 平台决策记录：偏移寻址、StoreRegister、隐式布尔转换 |

> 注：`evalorder.md` 记录的是求值顺序本身的规则。`TimSort.as` 文件头的"AS2/AVM1 平台决策记录"
> 是目前项目中对 AVM1 字节码行为最详尽的实测总结，涵盖偏移寻址 vs 自增、StoreRegister 机制、
> 隐式布尔转换快速路径等，均附有字节码反汇编验证。副作用压行触发寄存器优化的性能收益来自长期
> 工程实践验证，非单一基准测试。

### 综合与工程
| 文件 | 主题 |
|------|------|
| `对as2本身一些性能优化点的测试探索.md` | 综合性能优化探索 |
| `GitHub项目瘦身记录.md` | 仓库体积优化 |

---

## 2. 优化决策快查表

<!-- 持续补充：每次发现新的优化决策规则时追加 -->

| 场景 | 推荐方案 | 关键原理 | 来源 |
|------|----------|----------|------|
| 同一属性访问 ≥ 2 次 | `var local = obj.prop;` 缓存到局部变量 | 属性索引走哈希查找 + 作用域链，局部变量直接栈访问 | `哈希函数实现.md`、`BQP.as:1680-1741` |
| 类名极长 | `var CFR:Object = ColliderFactoryRegistry;` 别名缓存 | 减少属性查找 + 缩短字节码字符串常量 | `BQP.as:1688-1694` |
| 位掩码/状态标志等不变量 | `#include` 宏注入为函数内局部 `var`，组合常量预计算 | 编译期文本替换，零运行时类名查找 | `BQP.as:1670-1682` |
| 多步计算临时变量 | 副作用语句压行（`arr[--j+2]=tmp`），触发 StoreRegister | AVM1 副作用上下文走 StoreRegister（3 字节码），独立 `j--` 走 GetVariable/SetVariable 名查找（更慢） | `TimSort.as` 平台决策 + `evalorder.md` |
| 批量数组拷贝 | 4 路展开 + 偏移寻址 `arr[d+k]...d+=4` | `d+k` = 3 字节码，`d++` = 4 字节码，每 4 路净省 4 条指令。尾部余量(len&3)仍用 `d++` | `TimSort.as` 平台决策 |
| 布尔参与算术 | 直接使用比较结果，不用 `(cond ? 1 : 0)` | AVM1 ActionSubtract 硬连线 Boolean→Number 快速路径 | `TimSort.as` 平台决策 |
| 按计算键排序 | 预提取键到 Number 数组，内联 `keys[X] OP keys[Y]` | 消除比较器函数调用开销，38%~67% 提升 | `TimSort.sortIndirect()` 基准 |
| 循环首次迭代可保证执行 | 哨兵搬运 + `do-while` | 省去入口条件检查 | `TIMSORT_MERGE.as` P3 |
| 算法参数选择 | 随比较开销调整（如 MIN_GALLOP：函数调用=9，内联=7） | 算法参数不能照搬教科书默认值 | `TimSort.as` 两入口参数差异 |
| 字符串拼接 | 裸 `+` 拼接，不用 `Array.join()` | 实测 `join()` 远慢于 `+` | `字符串性能评估.md` |
| 取绝对值 | 位运算替代 `Math.abs()` | — | `abs取绝对值.md` |
| 取整 | 位运算替代 `Math.floor()` | — | `floor取整.md` |
| 热路径静态缓存 | 阈值释放（≤256 保留，>256 释放）+ `_inUse` 重入保护 + `resetState()` 安全阀 | 小缓存复用减 GC，大缓存释放防泄漏；重入时降级原生实现 | `TimSort.as` workspace |
| 大型函数变量声明 | 所有 `var` 集中到函数入口 | 避免 AVM1 循环内重复初始化 | `BQP.as:1748-1835` |
| 帧间临时数据（同步） | 静态预分配对象复用，不 `new` | 零 GC 压力 | `BQP.as:119-130` |
| 多维状态紧凑存储 | 位运算编码到单个 Number（`(id << N) \| mode`） | 避免每实例分配 Object | `BQP.as` cancelToken |
| 紧密循环对象属性数组 | SoA 拆分：对象数组 → 多个平行基元数组 | 按索引访问快于逐对象属性查找 | `BQP.as:1711-1741` |

> **BQP** = `BulletQueueProcessor.as`（缩写，避免表格过宽）

---

## 4. 使用说明

- 在编写性能敏感代码时，先检查本文档是否有相关主题的研究
- 如有，进入 `scripts/优化随笔/` 阅读完整研究报告后再做决策
- 新的性能发现应按照 `agentsDoc/self-optimization.md` 流程归档
