是，可以这么分阶段接入，而且从稳定性角度看是比较稳妥的做法。

更具体一点，推荐的判断顺序可以是：

在子技能函数里先做“外部限制”过滤：

被动技能是否存在 / 等级是否足够
MP 是否够
当前状态 / 否定按键（比如不能按后、不能在空中等）
读搓招系统输出（建议用 当前搓招名 或 当前搓招ID）：

if (自机.当前搓招名 == "波动拳") { …触发…; return; }
这样优先走 DFA 识别的路径。
只有在“当前搓招名为空或不匹配”时，再走旧逻辑：

比如：
if (!自机.当前搓招名 || 自机.当前搓招名 != "波动拳") { // 旧的按键组合检测 }
这里你可以继续保留“同帧同时按下”的精细写法，以及其它特殊情况的硬编码判断。
这样的好处：

现有招式手感不会一下子全变，DFA 识别和旧脚本逻辑并行一段时间，方便对比调试。
派生关系/可派生窗口暂时继续用原来的 _root.技能函数.XXX可派生，等主流程跑顺了，再按你说的节奏慢慢迁移到 XML 的 Derivations 上。
性能方面，这样多做一次字符串比较 + 若干旧 if 检查，成本在整个帧更新链里可以认为是零。
唯一要注意的点：

记得在“旧逻辑”分支里，最好只在 自机.当前搓招名 为空或 commandId == 0 时才启用，避免出现“同一输入既被 DFA 识别又被旧逻辑再触发一次”的双重触发。

