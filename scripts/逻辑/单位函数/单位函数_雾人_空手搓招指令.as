import org.flashNight.arki.spatial.move.*;
import org.flashNight.arki.item.*;
import org.flashNight.arki.unit.Action.Skill.*;

/**
 * 搓招执行返回值常量：
 * 0 - 未执行（条件不满足）
 * 1 - DFA识别执行
 * 2 - 帧检查执行（旧逻辑兜底）
 */

// 调试开关：设为true启用搓招触发监控
_root.技能函数.搓招调试 = true;

// 监控输出：招式名 + 触发方式 + 输入状态
// 同时负责标记搓招缓冲已消费，避免重复触发
_root.技能函数.搓招监控 = function(招式名:String, 触发码:Number):Number {
	var 自机:Object = _parent;

	// DFA触发时标记缓冲已消费，防止同一输入重复触发
	if(触发码 == 1) {
		自机.搓招缓冲已消费 = true;
	}

	if(_root.技能函数.搓招调试 && 触发码 > 0) {
		var 方式:String = (触发码 == 1) ? "DFA预输入" : "同帧检测";

		// 构造输入状态字符串
		var 输入状态:String = "";
		if(自机.左行) 输入状态 += "←";
		if(自机.右行) 输入状态 += "→";
		if(自机.上行) 输入状态 += "↑";
		if(自机.下行) 输入状态 += "↓";
		if(自机.动作A) 输入状态 += "A";
		if(自机.动作B) 输入状态 += "B";
		if(Key.isDown(_root.奔跑键)) 输入状态 += "+Shift";
		if(自机.doubleTapRunDirection == 1) 输入状态 += "(→→run)";
		else if(自机.doubleTapRunDirection == -1) 输入状态 += "(←←run)";

		// 缓冲帧差（仅DFA预输入时显示）
		var 缓冲延迟:String = "";
		if(触发码 == 1 && 自机.搓招缓冲帧 != undefined) {
			缓冲延迟 = " 延迟=" + (_root.帧计时器.当前帧数 - 自机.搓招缓冲帧) + "帧";
		}

		// 输出：帧数 + 招式 + 触发方式 + 当前按键 + DFA搓招名 + 缓冲延迟
		_root.发布消息(_root.帧计时器.当前帧数 + ":[搓招触发] " + 招式名 + " ← " + 方式
			+ " | 按键=[" + 输入状态 + "]"
			+ (触发码 == 1 ? " DFA识别=" + (自机.当前搓招名 || "无") + 缓冲延迟 : ""));
	}
	return 触发码;
};

_root.技能函数.使用波动拳 = function():Number {
	var 自机 = _parent;
	var 技能 = 自机.被动技能.拳脚攻击;
	if(!技能 || 技能.等级 < 5) return 0;

	// DFA优先
	if(自机.当前搓招名 == "波动拳") {
		_root.空手攻击路由.空手攻击标签跳转(自机, "波动拳");
		return _root.技能函数.搓招监控("波动拳", 1);
	}

	// 帧检查兜底：下前A
	if(!自机.当前搓招名 && 自机.下行 && 自机.动作A) {
		var 按前 = (自机.方向 == "右") ? 自机.右行 : 自机.左行;
		if(按前) {
			_root.空手攻击路由.空手攻击标签跳转(自机, "波动拳");
			return _root.技能函数.搓招监控("波动拳", 2);
		}
	}
	return 0;
};

_root.技能函数.使用诛杀步 = function():Number {
	var 自机 = _parent;
	var 技能 = 自机.被动技能.拳脚攻击;
	if(!技能 || 技能.等级 < 1 || !技能.启用) return 0;

	var 面右 = (自机.方向 == "右");
	var 不按后 = 面右 ? !自机.左行 : !自机.右行;

	// DFA优先
	if(自机.当前搓招名 == "诛杀步" && 不按后) {
		_root.空手攻击路由.空手攻击标签跳转(自机, "诛杀步");
		return _root.技能函数.搓招监控("诛杀步", 1);
	}

	// 帧检查兜底：双击前且不按后
	if(!自机.当前搓招名 && 不按后) {
		var 双击前 = 面右 ? (自机.doubleTapRunDirection == 1) : (自机.doubleTapRunDirection == -1);
		if(双击前) {
			_root.空手攻击路由.空手攻击标签跳转(自机, "诛杀步");
			return _root.技能函数.搓招监控("诛杀步", 2);
		}
	}
	return 0;
};

_root.技能函数.使用后撤步 = function():Number {
	var 自机 = _parent;
	var 技能 = 自机.被动技能.拳脚攻击;
	if(!技能 || 技能.等级 < 1 || !技能.启用) return 0;

	var 面右 = (自机.方向 == "右");
	var 不按前 = 面右 ? !自机.右行 : !自机.左行;

	// DFA优先
	if(自机.当前搓招名 == "后撤步" && 不按前) {
		_root.空手攻击路由.空手攻击标签跳转(自机, "后撤步");
		return _root.技能函数.搓招监控("后撤步", 1);
	}

	// 帧检查兜底：Shift+后且不按前
	if(!自机.当前搓招名 && 不按前 && Key.isDown(_root.奔跑键)) {
		var 按后 = 面右 ? 自机.左行 : 自机.右行;
		if(按后) {
			_root.空手攻击路由.空手攻击标签跳转(自机, "后撤步");
			return _root.技能函数.搓招监控("后撤步", 2);
		}
	}
	return 0;
};

_root.技能函数.使用燃烧指节 = function():Number {
	var 自机 = _parent;
	var 技能 = 自机.被动技能.升龙拳;
	if(!技能 || 技能.等级 < 1) return 0;

	// DFA优先
	if(自机.当前搓招名 == "燃烧指节") {
		_root.空手攻击路由.空手攻击标签跳转(自机, "燃烧指节");
		return _root.技能函数.搓招监控("燃烧指节", 1);
	}

	// 帧检查兜底：前B
	if(!自机.当前搓招名 && 自机.动作B) {
		var 按前 = (自机.方向 == "右") ? 自机.右行 : 自机.左行;
		if(按前) {
			_root.空手攻击路由.空手攻击标签跳转(自机, "燃烧指节");
			return _root.技能函数.搓招监控("燃烧指节", 2);
		}
	}
	return 0;
};

_root.技能函数.使用能量喷泉 = function():Number {
	var 自机 = _parent;
	var 技能 = 自机.被动技能.裂地拳;
	var 所需MP = 自机.mp满血值 * 0.1;
	if(!技能 || 技能.等级 < 1 || 自机.mp < 所需MP) return 0;

	// DFA优先
	if(自机.当前搓招名 == "能量喷泉") {
		_root.空手攻击路由.空手攻击标签跳转(自机, "能量喷泉");
		return _root.技能函数.搓招监控("能量喷泉", 1);
	}

	// 帧检查兜底：下B
	if(!自机.当前搓招名 && 自机.下行 && 自机.动作B) {
		_root.空手攻击路由.空手攻击标签跳转(自机, "能量喷泉");
		return _root.技能函数.搓招监控("能量喷泉", 2);
	}
	return 0;
};

_root.技能函数.使用连环踢 = function():Number {
	var 自机 = _parent;
	var 技能 = 自机.被动技能.拳脚攻击;
	if(!技能 || 技能.等级 < 1) return 0;

	// DFA优先
	if(自机.当前搓招名 == "连环踢") {
		_root.空手攻击路由.空手攻击标签跳转(自机, "连环踢");
		return _root.技能函数.搓招监控("连环踢", 1);
	}

	// 帧检查兜底：上A
	if(!自机.当前搓招名 && 自机.上行 && 自机.动作A) {
			_root.空手攻击路由.空手攻击标签跳转(自机, "连环踢");
			return _root.技能函数.搓招监控("连环踢", 2);

	}
	return 0;
};


_root.技能函数.空手攻击搓招 = function(跳跃兼容):Number {
	if(跳跃兼容){
		return _root.技能函数.使用能量喷泉()
			|| _root.技能函数.使用诛杀步()
			|| _root.技能函数.使用后撤步()
			|| _root.技能函数.使用波动拳()
			|| _root.技能函数.使用连环踢();
	}
	return _root.技能函数.使用能量喷泉()
		|| _root.技能函数.使用燃烧指节()
		|| _root.技能函数.使用诛杀步()
		|| _root.技能函数.使用后撤步()
		|| _root.技能函数.使用波动拳()
		|| _root.技能函数.使用连环踢();
};

_root.技能函数.波动拳可派生搓招 = function():Number {
	return _root.技能函数.使用能量喷泉()
		|| _root.技能函数.使用燃烧指节()
		|| _root.技能函数.使用诛杀步()
		|| _root.技能函数.使用后撤步()
		|| _root.技能函数.使用连环踢();
};

_root.技能函数.诛杀步可派生搓招 = function():Number {
	return _root.技能函数.使用能量喷泉()
		|| _root.技能函数.使用燃烧指节()
		|| _root.技能函数.使用后撤步()
		|| _root.技能函数.使用波动拳()
		|| _root.技能函数.使用连环踢();
};

_root.技能函数.后撤步可派生搓招 = function():Number {
	return _root.技能函数.使用能量喷泉()
		|| _root.技能函数.使用燃烧指节()
		|| _root.技能函数.使用诛杀步()
		|| _root.技能函数.使用波动拳()
		|| _root.技能函数.使用连环踢();
};

_root.技能函数.能量喷泉可派生搓招 = function():Number {
	return _root.技能函数.使用燃烧指节()
		|| _root.技能函数.使用诛杀步()
		|| _root.技能函数.使用后撤步()
		|| _root.技能函数.使用波动拳()
		|| _root.技能函数.使用连环踢();
};

_root.技能函数.燃烧指节可派生搓招 = function():Number {
	return _root.技能函数.使用能量喷泉()
		|| _root.技能函数.使用诛杀步()
		|| _root.技能函数.使用后撤步()
		|| _root.技能函数.使用波动拳()
		|| _root.技能函数.使用连环踢();
};

_root.技能函数.狼炮可派生搓招 = function():Number {
	return _root.技能函数.使用能量喷泉()
		|| _root.技能函数.使用诛杀步()
		|| _root.技能函数.使用后撤步()
		|| _root.技能函数.使用波动拳()
		|| _root.技能函数.使用连环踢();
};

_root.技能函数.连环踢可派生搓招 = function():Number {
	return _root.技能函数.使用能量喷泉()
		|| _root.技能函数.使用诛杀步()
		|| _root.技能函数.使用后撤步()
		|| _root.技能函数.使用波动拳()
};